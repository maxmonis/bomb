<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>BOMB Game</title>
    <style>
      #countdown {
        font-size: 2em;
        color: red;
      }
      .hidden {
        display: none;
      }
      .player-status {
        display: flex;
        justify-content: space-around;
        margin-bottom: 20px;
      }
      .player {
        text-align: center;
      }
      .bomb-letter {
        color: gray;
        font-size: 1.5em;
      }
      .bomb-letter.red {
        color: red;
      }
      #join-requests {
        margin: 20px 0;
      }
      .join-request {
        margin: 10px 0;
        padding: 10px;
        border: 1px solid #ccc;
      }
      #pending-message {
        margin: 20px 0;
        padding: 10px;
        background-color: #fff3cd;
        border: 1px solid #ffeeba;
        border-radius: 4px;
        color: #856404;
      }
      #selection-history {
        margin: 20px 0;
        padding: 15px;
        background-color: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 4px;
      }
      .selection-chain {
        font-size: 1.1em;
        color: #495057;
        line-height: 1.5;
        padding: 10px;
      }
      .movie-selection {
        color: #0066cc;
        font-weight: bold;
      }
      .actor-selection {
        color: #cc6600;
        font-weight: bold;
      }
    </style>
  </head>
  <body>
    <h1>BOMB Game</h1>

    <div id="lobby" class="hidden">
      <h2>Game Lobby</h2>
      <div id="available-games">
        <h3>Available Games</h3>
        <ul id="games-list"></ul>
      </div>
      <div id="create-game">
        <h3>Create New Game</h3>
        <input type="text" id="creator-name" placeholder="Enter your name" />
        <button id="create-game-btn">Create Game</button>
      </div>
      <div id="join-game">
        <h3>Join Game</h3>
        <input type="text" id="game-id" placeholder="Enter game ID" />
        <input type="text" id="player-name" placeholder="Enter your name" />
        <input
          type="text"
          id="join-message"
          placeholder="Message to creator (optional)"
        />
        <button id="join-game-btn">Join Game</button>
      </div>
    </div>

    <div id="waiting-room" class="hidden">
      <h2>Waiting Room</h2>
      <p>Game ID: <span id="game-id-display"></span></p>
      <div id="pending-message" class="hidden">
        <p>Waiting for the creator to admit you to the game...</p>
      </div>
      <h3>Players:</h3>
      <ul id="players-list"></ul>
      <div id="creator-controls" class="hidden">
        <h3>Join Requests:</h3>
        <div id="join-requests"></div>
        <button id="start-game-btn" disabled>Start Game</button>
      </div>
    </div>

    <div class="player-status hidden" id="player-status">
      <!-- Player statuses will be dynamically added here -->
    </div>

    <div id="game-area" class="hidden">
      <h2>Current Player: <span id="current-player"></span></h2>
      <div id="countdown">30</div>
      <div id="category-selection">
        <label
          ><input type="radio" name="category" value="movie" checked />
          Movie</label
        >
        <label
          ><input type="radio" name="category" value="actor" /> Actor</label
        >
      </div>
      <p id="instruction-text"></p>
      <input
        type="text"
        id="search-bar"
        placeholder="Search for a movie or actor"
      />
      <button id="search-button">Search</button>
      <ul id="search-results"></ul>
      <button id="challenge" class="hidden">Challenge</button>
      <button id="give-up" class="hidden">Give Up</button>
      <div id="selection-history">
        <h3>Selection Chain</h3>
        <div class="selection-chain"></div>
      </div>
    </div>

    <script>
      let ws
      let gameState = {
        id: null,
        playerName: null,
        isCreator: false,
        usedItems: new Set(),
        shouldReconnect: true,
        reconnectAttempts: 0,
        maxReconnectAttempts: 5,
        timerInterval: null,
        turnStartTime: null,
        timeLeft: 30,
      }

      // Function to start local countdown
      function startLocalCountdown() {
        // Clear any existing timer
        stopLocalCountdown()

        // Set initial state
        gameState.timeLeft = 30
        gameState.turnStartTime = Date.now()
        const countdownElement = document.getElementById("countdown")
        countdownElement.textContent = gameState.timeLeft

        // Start local countdown
        gameState.timerInterval = setInterval(() => {
          const elapsed = Math.floor(
            (Date.now() - gameState.turnStartTime) / 1000
          )
          gameState.timeLeft = Math.max(30 - elapsed, 0)
          countdownElement.textContent = gameState.timeLeft

          if (gameState.timeLeft === 0) {
            stopLocalCountdown()
            // Notify server that time has expired
            ws.send(JSON.stringify({ type: "time_expired" }))
          }
        }, 100) // Update more frequently for smoother display
      }

      // Function to stop local countdown
      function stopLocalCountdown() {
        if (gameState.timerInterval) {
          clearInterval(gameState.timerInterval)
          gameState.timerInterval = null
          gameState.turnStartTime = null
        }
      }

      // Check for existing game in localStorage on page load
      window.addEventListener("load", () => {
        const savedGameId = localStorage.getItem("gameId")
        if (savedGameId) {
          reconnectToGame()
        } else {
          document.getElementById("lobby").classList.remove("hidden")
        }
      })

      function connectToGame(gameId, playerName, isReconnect = false) {
        try {
          ws = new WebSocket(`ws://${window.location.host}/ws`, ["websocket"])

          ws.onopen = () => {
            // Reset reconnection attempts on successful connection
            gameState.reconnectAttempts = 0
            gameState.shouldReconnect = true
            gameState.playerName = playerName
            gameState.id = gameId

            // Send initial connection message
            ws.send(
              JSON.stringify({
                type: "connect",
                gameId: gameId,
                name: playerName,
                isReconnect: isReconnect,
              })
            )
          }

          ws.onerror = (error) => {
            console.error("WebSocket error:", error)
            if (ws.readyState !== WebSocket.OPEN) {
              handleReconnection()
            }
          }

          ws.onmessage = (event) => {
            const message = JSON.parse(event.data)
            console.log("Received message:", message) // Add logging
            handleWebSocketMessage(message)
          }

          ws.onclose = (event) => {
            console.log("WebSocket closed with code:", event.code)
            handleReconnection()
          }
        } catch (error) {
          console.error("Error creating WebSocket:", error)
          handleReconnection()
        }
      }

      function handleReconnection() {
        // Only try to reconnect if we haven't received a game not found error
        // and haven't exceeded max attempts
        if (
          gameState.shouldReconnect &&
          gameState.reconnectAttempts < gameState.maxReconnectAttempts
        ) {
          gameState.reconnectAttempts++
          const delay = Math.min(1000 * gameState.reconnectAttempts, 5000) // Max 5 second delay
          console.log(`Attempting to reconnect in ${delay / 1000} seconds...`)

          setTimeout(() => {
            if (gameState.id) {
              connectToGame(gameState.id, gameState.playerName, true)
            }
          }, delay)
        } else if (
          gameState.reconnectAttempts >= gameState.maxReconnectAttempts
        ) {
          // If we've exceeded max attempts, clear game state and return to lobby
          localStorage.removeItem("gameId")
          localStorage.removeItem("playerName")
          gameState.id = null
          gameState.playerName = null
          document.getElementById("lobby").classList.remove("hidden")
          document.getElementById("waiting-room").classList.add("hidden")
          document.getElementById("game-area").classList.add("hidden")
          alert("Unable to connect to game. Please try again.")
        }
      }

      function handleWebSocketMessage(message) {
        switch (message.type) {
          case "game_state":
            // Stop any existing countdown before updating game state
            stopLocalCountdown()
            updateGameState(message.game)
            break
          case "game_ended":
            // Stop countdown when game ends
            stopLocalCountdown()
            handleGameEnded(message)
            break
          case "available_games":
            updateAvailableGames(message.games)
            break
          case "join_accepted":
            // Remove pending message when accepted
            document.getElementById("pending-message").classList.add("hidden")
            document.getElementById("players-list").classList.remove("hidden")
            break
          case "error":
            if (message.message === "Game not found") {
              // Stop reconnection attempts if game doesn't exist
              gameState.shouldReconnect = false
              localStorage.removeItem("gameId")
              localStorage.removeItem("playerName")
              document.getElementById("lobby").classList.remove("hidden")
              document.getElementById("waiting-room").classList.add("hidden")
              document.getElementById("game-area").classList.add("hidden")
            } else if (message.message === "Your join request was rejected") {
              // Return to lobby if rejected
              localStorage.removeItem("gameId")
              localStorage.removeItem("playerName")
              document.getElementById("lobby").classList.remove("hidden")
              document.getElementById("waiting-room").classList.add("hidden")
              document.getElementById("game-area").classList.add("hidden")
              alert("Your join request was rejected")
            }
            break
        }
      }

      function updateGameState(game) {
        console.log("Game state update:", game)
        const statusDiv = document.getElementById("player-status")
        const waitingRoom = document.getElementById("waiting-room")
        const gameArea = document.getElementById("game-area")
        const playersList = document.getElementById("players-list")
        const creatorControls = document.getElementById("creator-controls")
        const pendingMessage = document.getElementById("pending-message")
        const searchWidgets = document.getElementById("category-selection")
        const searchBar = document.getElementById("search-bar")
        const searchButton = document.getElementById("search-button")
        const searchResults = document.getElementById("search-results")
        const countdownElement = document.getElementById("countdown")
        const selectionHistory = document.getElementById("selection-history")
        const selectionChain = document.querySelector(".selection-chain")

        // Clear the players list
        playersList.innerHTML = ""

        // Always update the players list when we have players
        game.players.forEach((player) => {
          const li = document.createElement("li")
          li.textContent = `${player.name}${
            player.name === game.creatorId ? " (Creator)" : ""
          }`
          // Add BOMB letters if any
          if (player.letters > 0) {
            const letters = "BOMB".slice(0, player.letters)
            li.textContent += ` [${letters}]`
          }
          playersList.appendChild(li)
        })

        // Update isCreator flag based on game state
        gameState.isCreator = game.creatorId === gameState.playerName

        // Check if current user is in a pending state
        const isPending =
          !gameState.isCreator &&
          game.joinRequests &&
          game.joinRequests[gameState.playerName] &&
          !game.players.some((p) => p.name === gameState.playerName)

        if (game.inProgress) {
          statusDiv.classList.remove("hidden")
          waitingRoom.classList.add("hidden")
          gameArea.classList.remove("hidden")
          pendingMessage.classList.add("hidden")

          // Update current player display
          const currentPlayerName = game.players[game.currentPlayer]?.name
          document.getElementById("current-player").textContent =
            currentPlayerName || ""

          // Handle timer based on game state
          if (game.inProgress) {
            // Only start a new timer if this is a new turn
            if (game.timeLeft === 30) {
              startLocalCountdown()
            } else if (game.timeLeft === 0) {
              stopLocalCountdown()
            }
          } else {
            stopLocalCountdown()
          }

          // Show/hide search widgets based on whether it's the current player's turn
          const isCurrentPlayer = currentPlayerName === gameState.playerName
          if (isCurrentPlayer) {
            searchWidgets.classList.remove("hidden")
            searchBar.classList.remove("hidden")
            searchButton.classList.remove("hidden")
            document.getElementById("instruction-text").textContent =
              "Your turn! Search for a movie or actor"

            // Update radio button based on previous selection
            if (game.lastCategory) {
              const nextCategory =
                game.lastCategory === "movie" ? "actor" : "movie"
              document.querySelector(
                `input[name="category"][value="${nextCategory}"]`
              ).checked = true
            }
          } else {
            searchWidgets.classList.add("hidden")
            searchBar.classList.add("hidden")
            searchButton.classList.add("hidden")
            searchResults.innerHTML = ""
            document.getElementById(
              "instruction-text"
            ).textContent = `${currentPlayerName} is thinking...`
          }

          // Show/hide challenge button
          const challengeBtn = document.getElementById("challenge")
          const giveUpBtn = document.getElementById("give-up")

          if (game.challengeState) {
            challengeBtn.classList.add("hidden")
            if (game.challengeState.challengedName === gameState.playerName) {
              giveUpBtn.classList.remove("hidden")
            } else {
              giveUpBtn.classList.add("hidden")
            }
          } else {
            giveUpBtn.classList.add("hidden")
            if (
              currentPlayerName !== gameState.playerName &&
              game.roundStarted
            ) {
              challengeBtn.classList.remove("hidden")
            } else {
              challengeBtn.classList.add("hidden")
            }
          }

          // Update selection history
          if (game.selectionHistory && game.selectionHistory.length > 0) {
            const chain = document.querySelector(".selection-chain")
            chain.innerHTML = game.selectionHistory
              .map((selection, idx) => {
                const type = idx % 2 === 0 ? "movie" : "actor"
                return `<span class="${type}-selection">${selection}</span>`
              })
              .join(" → ")
            document
              .getElementById("selection-history")
              .classList.remove("hidden")
          } else {
            document.getElementById("selection-history").classList.add("hidden")
          }
        } else {
          // ... rest of the existing waiting room code ...
          statusDiv.classList.add("hidden")
          waitingRoom.classList.remove("hidden")
          gameArea.classList.add("hidden")
          document.getElementById("game-id-display").textContent = game.id

          // Show/hide pending message
          if (isPending) {
            pendingMessage.classList.remove("hidden")
            playersList.classList.add("hidden")
          } else {
            pendingMessage.classList.add("hidden")
            playersList.classList.remove("hidden")
          }

          // Update creator controls
          if (gameState.isCreator) {
            creatorControls.classList.remove("hidden")
            const requestsDiv = document.getElementById("join-requests")
            requestsDiv.innerHTML = ""

            // Make sure joinRequests exists and is an object
            if (game.joinRequests && typeof game.joinRequests === "object") {
              console.log("Join requests:", game.joinRequests)
              Object.entries(game.joinRequests).forEach(([name, request]) => {
                const requestDiv = document.createElement("div")
                requestDiv.className = "join-request"
                requestDiv.innerHTML = `
                            <p><strong>${name}</strong></p>
                            ${
                              request.message
                                ? `<p>Message: ${request.message}</p>`
                                : ""
                            }
                            <button onclick="handleJoinRequest('${name}', true)">Admit</button>
                            <button onclick="handleJoinRequest('${name}', false)">Reject</button>
                        `
                requestsDiv.appendChild(requestDiv)
              })
            }

            // Update start button - enable only if there are 2 or more players
            const startButton = document.getElementById("start-game-btn")
            startButton.disabled = game.players.length < 2
          } else {
            creatorControls.classList.add("hidden")
          }
        }
      }

      function reconnectToGame() {
        const playerName = localStorage.getItem("playerName")
        const gameId = localStorage.getItem("gameId")
        if (playerName && gameId) {
          gameState.playerName = playerName
          gameState.id = gameId
          connectToGame(gameId, playerName, true)

          document.getElementById("lobby").classList.add("hidden")
          document.getElementById("waiting-room").classList.remove("hidden")
          document.getElementById("game-id-display").textContent = gameId
        } else {
          document.getElementById("lobby").classList.remove("hidden")
        }
      }

      function handleJoinRequest(playerName, isAdmitted) {
        ws.send(
          JSON.stringify({
            type: isAdmitted ? "admit_player" : "reject_player",
            content: { playerName },
          })
        )
      }

      // Event Listeners
      document
        .getElementById("create-game-btn")
        .addEventListener("click", async () => {
          const creatorName = document
            .getElementById("creator-name")
            .value.trim()
          if (!creatorName) {
            alert("Please enter your name")
            return
          }

          const response = await fetch("/create-game", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ creatorName }),
          })

          const data = await response.json()
          gameState.id = data.gameId
          gameState.isCreator = true
          gameState.playerName = creatorName

          // Save to localStorage
          localStorage.setItem("gameId", gameState.id)
          localStorage.setItem("playerName", creatorName)

          document.getElementById("game-id-display").textContent = gameState.id
          document.getElementById("lobby").classList.add("hidden")
          document.getElementById("waiting-room").classList.remove("hidden")

          connectToGame(gameState.id, creatorName)
        })

      document
        .getElementById("join-game-btn")
        .addEventListener("click", async () => {
          const gameId = document.getElementById("game-id").value.trim()
          const playerName = document.getElementById("player-name").value.trim()
          const message = document.getElementById("join-message").value.trim()

          if (!gameId || !playerName) {
            alert("Please enter both game ID and your name")
            return
          }

          try {
            const response = await fetch("/join-game", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ gameId, name: playerName, message }),
            })

            if (!response.ok) {
              const error = await response.text()
              throw new Error(error)
            }

            // Save to localStorage
            localStorage.setItem("gameId", gameId)
            localStorage.setItem("playerName", playerName)

            // Show waiting room and hide lobby
            document.getElementById("lobby").classList.add("hidden")
            document.getElementById("waiting-room").classList.remove("hidden")
            document.getElementById("game-id-display").textContent = gameId

            // Connect to WebSocket after join request is accepted
            connectToGame(gameId, playerName)
          } catch (error) {
            alert(error.message)
          }
        })

      // Game event handlers
      document
        .getElementById("search-button")
        .addEventListener("click", async () => {
          const query = document.getElementById("search-bar").value.trim()
          if (!query) return

          const category = document.querySelector(
            'input[name="category"]:checked'
          )?.value

          try {
            const params = new URLSearchParams({
              query,
              category,
            })

            // Add lastSelection if it exists
            if (gameState.lastSelection) {
              params.append("lastSelection", gameState.lastSelection)
            }

            const response = await fetch(`/search?${params}`)

            if (!response.ok) {
              throw new Error(`HTTP error! status: ${response.status}`)
            }

            const results = await response.json()

            const resultsList = document.getElementById("search-results")
            resultsList.innerHTML = ""

            if (!results || results.length === 0) {
              resultsList.innerHTML = "<li>No results found</li>"
              return
            }

            results.forEach((result) => {
              const li = document.createElement("li")
              li.textContent = result
              const selectBtn = document.createElement("button")
              selectBtn.textContent = "Select"
              selectBtn.onclick = () => {
                makeSelection(result, category)
                // Clear search results after selection
                resultsList.innerHTML = ""
                document.getElementById("search-bar").value = ""
                // Update game state with the selection
                gameState.lastSelection = result
                gameState.lastCategory = category
                // Start timer for next player
                ws.send(JSON.stringify({ type: "start_turn" }))
              }
              li.appendChild(selectBtn)
              resultsList.appendChild(li)
            })
          } catch (error) {
            console.error("Search error:", error)
            const resultsList = document.getElementById("search-results")
            resultsList.innerHTML =
              "<li>Failed to fetch results. Please try again.</li>"
          }
        })

      function makeSelection(selection, category) {
        // Stop countdown when making a selection
        stopLocalCountdown()
        ws.send(
          JSON.stringify({
            type: "make_selection",
            content: { selection, category },
          })
        )

        // Update local state
        gameState.lastSelection = selection
        gameState.lastCategory = category

        // Set the opposite category for the next player
        const nextCategory = category === "movie" ? "actor" : "movie"
        document.querySelector(
          `input[name="category"][value="${nextCategory}"]`
        ).checked = true
      }

      function handleGameEnded(message) {
        alert(message.message)
        localStorage.removeItem("gameId")
        localStorage.removeItem("playerName")
        location.reload()
      }

      // Challenge and Give Up functionality remains similar to before,
      // but now sends WebSocket messages instead of handling locally
      document.getElementById("challenge").addEventListener("click", () => {
        // Stop countdown when challenging
        stopLocalCountdown()
        ws.send(JSON.stringify({ type: "challenge" }))
      })

      document.getElementById("give-up").addEventListener("click", () => {
        // Stop countdown when giving up
        stopLocalCountdown()
        ws.send(JSON.stringify({ type: "give_up" }))
      })

      document
        .getElementById("start-game-btn")
        .addEventListener("click", () => {
          ws.send(JSON.stringify({ type: "start_game" }))
        })

      function updateAvailableGames(games) {
        const gamesList = document.getElementById("games-list")
        gamesList.innerHTML = ""
        games.forEach((gameId) => {
          const li = document.createElement("li")
          li.textContent = `Game ID: ${gameId}`
          const joinBtn = document.createElement("button")
          joinBtn.textContent = "Join"
          joinBtn.onclick = () => {
            document.getElementById("game-id").value = gameId
            document.getElementById("game-id").scrollIntoView()
          }
          li.appendChild(joinBtn)
          gamesList.appendChild(li)
        })
      }

      // Connect to WebSocket for lobby updates when page loads
      if (!localStorage.getItem("gameId")) {
        connectToGame(null, null) // Connect without game ID for lobby updates
      }

      function connectToLobby() {
        const wsProtocol =
          window.location.protocol === "https:" ? "wss:" : "ws:"
        const wsUrl = `${wsProtocol}//${window.location.host}/ws`
        const socket = new WebSocket(wsUrl)

        socket.onopen = () => {
          socket.send(JSON.stringify({ type: "lobby" }))
        }

        socket.onmessage = (event) => {
          const data = JSON.parse(event.data)
          if (data.type === "available_games") {
            updateGamesList(data.games)
          }
        }

        socket.onclose = () => {
          setTimeout(connectToLobby, 1000) // Reconnect on connection loss
        }
      }

      function updateGamesList(games) {
        const gamesList = document.getElementById("games-list")
        gamesList.innerHTML = ""
        games.forEach((gameId) => {
          const li = document.createElement("li")
          const joinButton = document.createElement("button")
          joinButton.textContent = "Join Game"
          joinButton.onclick = () => {
            document.getElementById("game-id").value = gameId
          }
          li.textContent = `Game: ${gameId} `
          li.appendChild(joinButton)
          gamesList.appendChild(li)
        })
      }

      // Initialize WebSocket connection when page loads
      window.addEventListener("load", connectToLobby)
      // Remove the polling interval since we're using WebSocket now
    </script>
  </body>
</html>
